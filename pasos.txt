A continuación te sugiero algunos pasos para continuar y completar el proyecto:

1. **Captura del ARP Request:**  
   - Implementa la lógica para detectar el ARP request enviado en broadcast. Puedes usar funciones como recvfrom en un socket RAW o utilizar una librería como libpcap, siempre que sea permitido.
   - Muestra mensajes informativos (por ejemplo, “An ARP request has been broadcast”) e imprime, si es posible, la dirección IP y la MAC de quien lo envió.

2. **Envio del ARP Reply:**  
   - Una vez detectado el ARP request para la IP fuente, construye un paquete ARP reply usando los datos ingresados (source IP/MAC y target IP/MAC).
   - Asegúrate de rellenar correctamente los campos ARP de hardware, protocolo y direcciones.
   - Utiliza sendto para enviar el paquete a la interfaz correcta.

3. **Validación y seguridad:**  
   - Verifica que la IP fuente (spoofeada) realmente pertenezca a la interfaz de la VM, ya que el proyecto indica que sólo se deben utilizar IPs propias.
   - Maneja adecuadamente errores y casos inesperados (por ejemplo, si no se recibe ningún ARP request en un tiempo razonable).

4. **Salida limpia del programa:**  
   - Asegúrate de que, una vez enviado el ARP reply, el programa libere recursos y salga de forma limpia.
   - Considera el manejo de la señal SIGINT (Ctrl+C) para garantizar una salida controlada.

5. **Implementación de los Bonus (si ya tienes todo el obligatorio funcionando):**  
   - Puedes mejorar el proyecto implementando la notación decimal para direcciones IPv4, resolución de nombres, o un modo verbose para mostrar la información del paquete ARP.
   - Estos bonus serán evaluados únicamente si el obligatorio es perfecto, así que asegúrate de que la parte principal esté completamente funcional.

Estos pasos te ayudarán a pasar de la parte de parseo y validación de argumentos hacia la lógica de red real que constituye el “spoofing” y ataque Man In The Middle. ¡Sigue así y buena suerte con el proyecto!

ft_malcolm/                           
├── Makefile                          
├── include/                          
│   ├── ft_malcolm.h                  # Archivo principal que incluye todos los demás .h para facilitar el uso
│   ├── types.h                       # Definiciones de estructuras y tipos de datos usados en el proyecto
│   ├── parse.h                       # Declaraciones de funciones para analizar argumentos de entrada
│   ├── arp.h                         # Declaraciones de funciones para manejar paquetes ARP
│   ├── net.h                         # Declaraciones de funciones para redes y sockets
│   ├── error.h                       # Declaraciones de funciones para manejar errores
│   ├── signals.h                     # Declaraciones de funciones para señales del sistema (ej. Ctrl+C)
│   └── libft/...                     # Carpeta con la biblioteca libft (funciones auxiliares)
├── libft/                            
├── src/                              
│   ├── core/                         # Subcarpeta para la lógica central del programa
│   │   ├── main.c                    # Archivo principal que inicia el programa
│   │   └── run.c                     # Archivo opcional para la lógica principal de ejecución
│   ├── parse/                        # Subcarpeta para analizar y validar entradas
│   │   ├── args_parse.c              # Código para procesar los argumentos del programa
│   │   ├── validate_ip.c             # Código para verificar direcciones IP
│   │   └── validate_mac.c            # Código para verificar direcciones MAC
│   ├── arp/                          # Subcarpeta para todo lo relacionado con ARP
│   │   ├── arp_listen.c              # Código para esperar y detectar solicitudes ARP
│   │   ├── arp_reply.c               # Código para enviar respuestas ARP falsas
│   │   └── arp_packet.c              # Código para construir paquetes ARP
│   ├── net/                          # Subcarpeta para funciones de red
│   │   ├── socket_raw.c              # Código para crear conexiones de red de bajo nivel
│   │   ├── interface.c               # Código para obtener información de la interfaz de red
│   │   └── network_utils.c           # Código auxiliar para redes (puedes dividirlo en los anteriores)
│   ├── signals/                      # Subcarpeta para manejar señales del sistema
│   │   └── signals.c                 # Código para configurar y responder a señales como Ctrl+C
│   └── utils/                        # Subcarpeta para utilidades generales
│       ├── error.c                   # Código para mostrar y manejar errores
│       ├── hex.c                     # Código para trabajar con números hexadecimales
│       └── dump.c                    # Código opcional para mostrar información detallada (modo verbose)
├── obj/                              
└── README.md                         

Carpeta raíz (ft_malcolm/): Es el "hogar" de todo el proyecto, donde viven todos los archivos.
Makefile: Es como una receta que le dice a la computadora cómo preparar (compilar) el programa. Incluye pasos para limpiar, construir y probar.
include/: Aquí van las "instrucciones" o definiciones que otros archivos necesitan. Es como un diccionario compartido que explica qué son las cosas (tipos de datos, funciones) sin repetir código.
libft/: Una biblioteca externa con herramientas útiles, como una caja de herramientas prestada que usas para tareas comunes.
src/: El corazón del proyecto, dividido en subcarpetas para no mezclar cosas. Cada subcarpeta agrupa tareas similares:
core/: Lo básico para que el programa funcione, como el punto de inicio.
parse/: Para revisar y entender lo que el usuario escribe al ejecutar el programa.
arp/: Para manejar las comunicaciones especiales de red que usa el proyecto.
net/: Para conectar con la red y obtener información necesaria.
signals/: Para responder a interrupciones, como cuando el usuario presiona Ctrl+C.
utils/: Herramientas pequeñas y útiles que se usan en varios lugares.


Problemas que veo en tu código actual:
Los argumentos no se están guardando - en parse.c creas una variable local args que se pierde
No estás detectando si el ARP request es para tu IP objetivo
No tienes función para enviar ARP reply
Pasos a seguir:
1. Guardar los argumentos globalmente
Modificar parse_args para que devuelva la estructura t_args
Modificar main.c para guardar los argumentos y pasarlos a listen_arp
2. Crear función para enviar ARP reply
Agregar archivo arp_request.c (aunque mejor sería arp_reply.c)
Implementar función que construya y envíe el paquete ARP reply
3. Modificar arp_listen.c
Cambiar print_arp_request para que compare si la IP solicitada es tu source_ip
Si coincide, llamar a la función de envío de ARP reply
Salir del programa después de enviar la respuesta
4. Agregar funciones auxiliares
Función para convertir MAC string a bytes
Función para obtener índice de interfaz de red

En los argumentos del programa:

source_ip = IP que quieres suplantar
source_mac = MAC falsa que quieres asociar con esa IP
target_ip = IP de la víctima (quien recibirá la respuesta falsa)
target_mac = MAC de la víctima
En el flujo del ataque:

Alguien (puede ser el target u otra máquina) pregunta: "¿Quién tiene source_ip?"
Tu programa responde: "Yo tengo source_ip, mi MAC es source_mac" (mintiendo)
Esta respuesta se envía específicamente al target_ip

En los argumentos del programa:

source_ip = IP que quieres SUPLANTAR (no es tu IP real)
target_ip = IP de la VÍCTIMA (quien recibirá la respuesta falsa)
El flujo del ataque es:
Alguien en la red pregunta: "¿Quién tiene source_ip?"
Tu programa responde: "Yo tengo source_ip, mi MAC es source_mac" (MENTIRA)
Esta respuesta se envía a: target_ip (la víctima)

jemplo con tus parámetros:
source_ip = 192.168.1.131 (IP que vas a suplantar)
target_ip = 192.168.1.132 (víctima que recibirá tu respuesta falsa)
Por eso comparas con source_ip:
Cuando alguien pregunta "¿Quién tiene 192.168.1.131?", tu programa dice "Yo la tengo" y envía esa respuesta específicamente a 192.168.1.132.

El objetivo del ataque:
Que la máquina 192.168.1.132 piense que la IP 192.168.1.131 tiene una MAC falsa (la tuya), interceptando así el tráfico destinado a 192.168.1.131.

